{
  "version": 3,
  "sources": [],
  "debugId": "c8437574-799d-0c3a-1ccf-fe6c17b0a4d4",
  "sections": [
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/isak/CLAUDE/projects/1.%20Loop%20Desk/src/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { PrismaPg } from \"@prisma/adapter-pg\";\nimport { Pool } from \"pg\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nfunction createPrismaClient(): PrismaClient {\n  const connectionString = process.env.DATABASE_URL;\n\n  if (!connectionString) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  // Create pg Pool for Supabase connection pooling\n  const pool = new Pool({ connectionString });\n  const adapter = new PrismaPg(pool);\n\n  return new PrismaClient({\n    adapter,\n    log: process.env.NODE_ENV === \"development\" ? [\"error\", \"warn\"] : [\"error\"],\n  });\n}\n\n// Lazy initialization to avoid errors during build\nlet prismaInstance: PrismaClient | null = null;\n\nexport const prisma = new Proxy({} as PrismaClient, {\n  get(_target, prop) {\n    if (!prismaInstance) {\n      prismaInstance = globalForPrisma.prisma ?? createPrismaClient();\n      if (process.env.NODE_ENV !== \"production\") {\n        globalForPrisma.prisma = prismaInstance;\n      }\n    }\n    return (prismaInstance as unknown as Record<string, unknown>)[prop as string];\n  },\n});\n\n// Helper to create title hash for grouping related articles\nexport function createTitleHash(title: string): string {\n  // Normalize title for comparison\n  const normalized = title\n    .toLowerCase()\n    .replace(/[^\\w\\s]/g, \"\")\n    .replace(/\\s+/g, \" \")\n    .trim()\n    .split(\" \")\n    .slice(0, 6) // First 6 words\n    .join(\" \");\n\n  // Simple hash function\n  let hash = 0;\n  for (let i = 0; i < normalized.length; i++) {\n    const char = normalized.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return hash.toString(36);\n}\n\n// Check if article matches any keywords\nexport async function checkKeywordMatches(\n  articleId: string,\n  title: string,\n  description: string | null\n): Promise<void> {\n  const keywords = await prisma.keyword.findMany({\n    where: { isActive: true },\n  });\n\n  for (const keyword of keywords) {\n    const term = keyword.term.toLowerCase();\n    const titleLower = title.toLowerCase();\n    const descLower = (description || \"\").toLowerCase();\n\n    let matchedIn: string | null = null;\n\n    if (titleLower.includes(term)) {\n      matchedIn = \"title\";\n    } else if (descLower.includes(term)) {\n      matchedIn = \"description\";\n    }\n\n    if (matchedIn) {\n      await prisma.keywordMatch.upsert({\n        where: {\n          articleId_keywordId: {\n            articleId,\n            keywordId: keyword.id,\n          },\n        },\n        create: {\n          articleId,\n          keywordId: keyword.id,\n          matchedIn,\n        },\n        update: {},\n      });\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;;;;;;AAEA,MAAM,kBAAkB;AAIxB,SAAS;IACP,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY;IAEjD,IAAI,CAAC,kBAAkB;QACrB,MAAM,IAAI,MAAM;IAClB;IAEA,iDAAiD;IACjD,MAAM,OAAO,IAAI,gMAAI,CAAC;QAAE;IAAiB;IACzC,MAAM,UAAU,IAAI,oNAAQ,CAAC;IAE7B,OAAO,IAAI,iPAAY,CAAC;QACtB;QACA,KAAK,uCAAyC;YAAC;YAAS;SAAO,GAAG;IACpE;AACF;AAEA,mDAAmD;AACnD,IAAI,iBAAsC;AAEnC,MAAM,SAAS,IAAI,MAAM,CAAC,GAAmB;IAClD,KAAI,OAAO,EAAE,IAAI;QACf,IAAI,CAAC,gBAAgB;YACnB,iBAAiB,gBAAgB,MAAM,IAAI;YAC3C,wCAA2C;gBACzC,gBAAgB,MAAM,GAAG;YAC3B;QACF;QACA,OAAO,AAAC,cAAqD,CAAC,KAAe;IAC/E;AACF;AAGO,SAAS,gBAAgB,KAAa;IAC3C,iCAAiC;IACjC,MAAM,aAAa,MAChB,WAAW,GACX,OAAO,CAAC,YAAY,IACpB,OAAO,CAAC,QAAQ,KAChB,IAAI,GACJ,KAAK,CAAC,KACN,KAAK,CAAC,GAAG,GAAG,gBAAgB;KAC5B,IAAI,CAAC;IAER,uBAAuB;IACvB,IAAI,OAAO;IACX,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IAAK;QAC1C,MAAM,OAAO,WAAW,UAAU,CAAC;QACnC,OAAO,AAAC,CAAC,QAAQ,CAAC,IAAI,OAAQ;QAC9B,OAAO,OAAO;IAChB;IACA,OAAO,KAAK,QAAQ,CAAC;AACvB;AAGO,eAAe,oBACpB,SAAiB,EACjB,KAAa,EACb,WAA0B;IAE1B,MAAM,WAAW,MAAM,OAAO,OAAO,CAAC,QAAQ,CAAC;QAC7C,OAAO;YAAE,UAAU;QAAK;IAC1B;IAEA,KAAK,MAAM,WAAW,SAAU;QAC9B,MAAM,OAAO,QAAQ,IAAI,CAAC,WAAW;QACrC,MAAM,aAAa,MAAM,WAAW;QACpC,MAAM,YAAY,CAAC,eAAe,EAAE,EAAE,WAAW;QAEjD,IAAI,YAA2B;QAE/B,IAAI,WAAW,QAAQ,CAAC,OAAO;YAC7B,YAAY;QACd,OAAO,IAAI,UAAU,QAAQ,CAAC,OAAO;YACnC,YAAY;QACd;QAEA,IAAI,WAAW;YACb,MAAM,OAAO,YAAY,CAAC,MAAM,CAAC;gBAC/B,OAAO;oBACL,qBAAqB;wBACnB;wBACA,WAAW,QAAQ,EAAE;oBACvB;gBACF;gBACA,QAAQ;oBACN;oBACA,WAAW,QAAQ,EAAE;oBACrB;gBACF;gBACA,QAAQ,CAAC;YACX;QACF;IACF;AACF"}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":["file:///Users/isak/CLAUDE/projects/1.%20Loop%20Desk/src/lib/auth/rate-limit.ts"],"sourcesContent":["/**\n * Rate limiting and account lockout for authentication\n *\n * Rules:\n * - Max 5 failed attempts per minute (rate limit)\n * - Max 10 total failed attempts before account lockout\n * - Lockout duration: 15 minutes\n */\n\nimport { prisma } from \"@/lib/db\";\n\ninterface RateLimitResult {\n  allowed: boolean;\n  error?: \"RATE_LIMITED\" | \"ACCOUNT_LOCKED\" | \"ACCOUNT_NOT_FOUND\" | \"INVALID_CREDENTIALS\";\n  remainingAttempts?: number;\n  lockoutMinutes?: number;\n  retryAfterSeconds?: number;\n}\n\n// In-memory store for rate limiting (per-minute tracking)\n// In production, consider using Redis for distributed systems\nconst rateLimitStore = new Map<string, { attempts: number; windowStart: number }>();\n\nconst RATE_LIMIT_WINDOW_MS = 60 * 1000; // 1 minute\nconst MAX_ATTEMPTS_PER_WINDOW = 5;\nconst MAX_FAILED_ATTEMPTS_BEFORE_LOCKOUT = 10;\nconst LOCKOUT_DURATION_MS = 15 * 60 * 1000; // 15 minutes\n\n/**\n * Check if a login attempt is allowed based on rate limiting\n */\nfunction checkRateLimit(email: string): { allowed: boolean; retryAfterSeconds?: number } {\n  const now = Date.now();\n  const key = email.toLowerCase();\n  const record = rateLimitStore.get(key);\n\n  if (!record) {\n    rateLimitStore.set(key, { attempts: 1, windowStart: now });\n    return { allowed: true };\n  }\n\n  // Check if we're in a new window\n  if (now - record.windowStart > RATE_LIMIT_WINDOW_MS) {\n    rateLimitStore.set(key, { attempts: 1, windowStart: now });\n    return { allowed: true };\n  }\n\n  // Check if rate limit exceeded\n  if (record.attempts >= MAX_ATTEMPTS_PER_WINDOW) {\n    const retryAfterSeconds = Math.ceil((record.windowStart + RATE_LIMIT_WINDOW_MS - now) / 1000);\n    return { allowed: false, retryAfterSeconds };\n  }\n\n  // Increment attempts\n  record.attempts++;\n  return { allowed: true };\n}\n\n/**\n * Reset rate limit for an email (called on successful login)\n */\nfunction resetRateLimit(email: string): void {\n  rateLimitStore.delete(email.toLowerCase());\n}\n\n/**\n * Check if account is locked and handle failed attempt tracking\n */\nexport async function checkLoginAttempt(email: string): Promise<RateLimitResult> {\n  // First check rate limit\n  const rateLimitCheck = checkRateLimit(email);\n  if (!rateLimitCheck.allowed) {\n    return {\n      allowed: false,\n      error: \"RATE_LIMITED\",\n      retryAfterSeconds: rateLimitCheck.retryAfterSeconds,\n    };\n  }\n\n  // Check if user exists and if account is locked\n  try {\n    const user = await prisma.user.findUnique({\n      where: { email: email.toLowerCase() },\n      select: {\n        id: true,\n        failedLoginAttempts: true,\n        lockedUntil: true,\n      },\n    });\n\n    if (!user) {\n      return { allowed: true }; // Let auth handle \"user not found\"\n    }\n\n    // Check if account is locked\n    if (user.lockedUntil && new Date(user.lockedUntil) > new Date()) {\n      const lockoutMinutes = Math.ceil(\n        (new Date(user.lockedUntil).getTime() - Date.now()) / (60 * 1000)\n      );\n      return {\n        allowed: false,\n        error: \"ACCOUNT_LOCKED\",\n        lockoutMinutes,\n      };\n    }\n\n    // If lock has expired, reset it\n    if (user.lockedUntil && new Date(user.lockedUntil) <= new Date()) {\n      await prisma.user.update({\n        where: { id: user.id },\n        data: {\n          failedLoginAttempts: 0,\n          lockedUntil: null,\n        },\n      });\n    }\n\n    const remainingAttempts = MAX_FAILED_ATTEMPTS_BEFORE_LOCKOUT - (user.failedLoginAttempts || 0);\n    return { allowed: true, remainingAttempts };\n  } catch (error) {\n    console.error(\"[RateLimit] Error checking login attempt:\", error);\n    return { allowed: true }; // Fail open - allow attempt if DB error\n  }\n}\n\n/**\n * Record a failed login attempt\n */\nexport async function recordFailedAttempt(email: string): Promise<RateLimitResult> {\n  try {\n    const user = await prisma.user.findUnique({\n      where: { email: email.toLowerCase() },\n      select: { id: true, failedLoginAttempts: true },\n    });\n\n    if (!user) {\n      return { allowed: false, error: \"ACCOUNT_NOT_FOUND\" };\n    }\n\n    const newFailedAttempts = (user.failedLoginAttempts || 0) + 1;\n    const shouldLock = newFailedAttempts >= MAX_FAILED_ATTEMPTS_BEFORE_LOCKOUT;\n\n    await prisma.user.update({\n      where: { id: user.id },\n      data: {\n        failedLoginAttempts: newFailedAttempts,\n        lockedUntil: shouldLock ? new Date(Date.now() + LOCKOUT_DURATION_MS) : null,\n      },\n    });\n\n    if (shouldLock) {\n      return {\n        allowed: false,\n        error: \"ACCOUNT_LOCKED\",\n        lockoutMinutes: 15,\n      };\n    }\n\n    return {\n      allowed: false,\n      error: \"INVALID_CREDENTIALS\",\n      remainingAttempts: MAX_FAILED_ATTEMPTS_BEFORE_LOCKOUT - newFailedAttempts,\n    };\n  } catch (error) {\n    console.error(\"[RateLimit] Error recording failed attempt:\", error);\n    return { allowed: false, error: \"INVALID_CREDENTIALS\" };\n  }\n}\n\n/**\n * Record a successful login (reset failed attempts)\n */\nexport async function recordSuccessfulLogin(email: string): Promise<void> {\n  resetRateLimit(email);\n\n  try {\n    await prisma.user.update({\n      where: { email: email.toLowerCase() },\n      data: {\n        failedLoginAttempts: 0,\n        lockedUntil: null,\n        lastLoginAt: new Date(),\n      },\n    });\n  } catch (error) {\n    console.error(\"[RateLimit] Error recording successful login:\", error);\n  }\n}\n\n/**\n * Get error message for display\n */\nexport function getErrorMessage(error: RateLimitResult[\"error\"], details?: RateLimitResult): string {\n  switch (error) {\n    case \"RATE_LIMITED\":\n      return `För många försök. Vänta ${details?.retryAfterSeconds || 60} sekunder.`;\n    case \"ACCOUNT_LOCKED\":\n      return `Kontot är låst i ${details?.lockoutMinutes || 15} minuter pga för många misslyckade försök.`;\n    case \"ACCOUNT_NOT_FOUND\":\n      return \"Inget konto hittades med denna e-postadress.\";\n    case \"INVALID_CREDENTIALS\":\n      if (details?.remainingAttempts !== undefined && details.remainingAttempts <= 3) {\n        return `Fel lösenord. ${details.remainingAttempts} försök kvar innan kontot låses.`;\n      }\n      return \"Fel e-postadress eller lösenord.\";\n    default:\n      return \"Något gick fel. Försök igen.\";\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 383, "column": 0}, "map": {"version":3,"sources":["file:///Users/isak/CLAUDE/projects/1.%20Loop%20Desk/src/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport Credentials from \"next-auth/providers/credentials\";\nimport Google from \"next-auth/providers/google\";\nimport bcrypt from \"bcryptjs\";\nimport { prisma } from \"@/lib/db\";\nimport {\n  checkLoginAttempt,\n  recordFailedAttempt,\n  recordSuccessfulLogin,\n} from \"@/lib/auth/rate-limit\";\n\n\n// Whitelist of allowed email addresses\nconst ALLOWED_EMAILS = [\n  \"andreas@loop.se\",\n  \"johann@loop.se\",\n  \"jenny@loop.se\",\n  \"camilla@loop.se\",\n  \"diana@loop.se\",\n  \"sandra@loop.se\",\n  \"christian@loop.se\",\n  \"isak.skogstad@me.com\",\n];\n\n// Map email to avatar image\nconst EMAIL_TO_AVATAR: Record<string, string> = {\n  \"andreas@loop.se\": \"/avatars/andreas-jennische.png\",\n  \"johann@loop.se\": \"/avatars/johann-bernovall.png\",\n  \"jenny@loop.se\": \"/avatars/jenny-kjellen.png\",\n  \"camilla@loop.se\": \"/avatars/camilla-bergman.png\",\n  \"diana@loop.se\": \"/avatars/diana-demin.png\",\n  \"sandra@loop.se\": \"/avatars/sandra-norberg.png\",\n  \"christian@loop.se\": \"/avatars/christian-von-essen.png\",\n  \"isak.skogstad@me.com\": \"/avatars/isak-skogstad.png\",\n};\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  adapter: PrismaAdapter(prisma),\n  session: {\n    strategy: \"jwt\",\n    maxAge: 30 * 24 * 60 * 60, // 30 days\n  },\n  pages: {\n    signIn: \"/login\",\n    error: \"/login\",\n  },\n  debug: process.env.NODE_ENV === \"development\",\n  logger: {\n    error(error) {\n      const message = error instanceof Error ? error.message : String(error);\n      if (message.includes(\"CredentialsSignin\")) {\n        console.warn(\"[auth][warn] CredentialsSignin\");\n        return;\n      }\n      console.error(\"[auth][error]\", error);\n    },\n  },\n  providers: [\n    Google({\n      clientId: process.env.GOOGLE_CLIENT_ID,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n    }),\n    Credentials({\n      name: \"credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Lösenord\", type: \"password\" },\n      },\n      authorize: async (credentials) => {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const email = (credentials.email as string).toLowerCase();\n        const password = credentials.password as string;\n\n        // Check rate limiting and account lockout\n        const loginCheck = await checkLoginAttempt(email);\n        if (!loginCheck.allowed) {\n          console.warn(`[auth] Login blocked for ${email}: ${loginCheck.error}`);\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: { email },\n        });\n\n        if (!user || !user.passwordHash) {\n          // Record failed attempt even for non-existent users (timing attack prevention)\n          await recordFailedAttempt(email);\n          return null;\n        }\n\n        const isValid = await bcrypt.compare(password, user.passwordHash);\n\n        if (!isValid) {\n          await recordFailedAttempt(email);\n          return null;\n        }\n\n        // Successful login - reset counters\n        await recordSuccessfulLogin(email);\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          image: user.image,\n          role: user.role,\n        };\n      },\n    }),\n  ],\n  callbacks: {\n    async signIn({ user, account }) {\n      // Allow credentials login (admin) without email check\n      if (account?.provider === \"credentials\") {\n        return true;\n      }\n\n      // For OAuth providers, check whitelist\n      if (user.email && ALLOWED_EMAILS.includes(user.email.toLowerCase())) {\n        // Set custom avatar based on email (no DB call needed)\n        const customAvatar = EMAIL_TO_AVATAR[user.email.toLowerCase()];\n        if (customAvatar) {\n          user.image = customAvatar;\n        }\n        return true;\n      }\n\n      // Reject if email not in whitelist\n      return false;\n    },\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n        token.role = (user as { role?: string }).role || \"user\";\n        token.picture = user.image;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token && session.user) {\n        session.user.id = token.id as string;\n        session.user.role = token.role as string;\n        session.user.image = token.picture as string;\n      }\n      return session;\n    },\n  },\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 556, "column": 0}, "map": {"version":3,"sources":["file:///Users/isak/CLAUDE/projects/1.%20Loop%20Desk/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import { handlers } from \"@/auth\";\n\nexport const { GET, POST } = handlers;\n"],"names":[],"mappings":";;;;;;AAAA;;;;;;AAEO,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,oKAAQ"}}]
}