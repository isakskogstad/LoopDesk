{
  "version": 3,
  "sources": [],
  "debugId": "86f01bb7-7cfe-b65d-88f4-edea9671548a",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../../../CLAUDE/projects/1.%20Loop%20Desk/src/lib/kungorelser/proxy-init.ts"],"sourcesContent":["/**\n * Proxy Manager Initialization - Auto-refresh for Railway deployments\n *\n * Railway assigns new IP on each deploy â†’ proxies need refreshing\n * This module ensures proxies are always fresh\n */\n\nimport { proxyManager } from './proxy-manager';\n\n// Track last refresh\nlet lastRefresh = 0;\nlet refreshInterval: NodeJS.Timeout | null = null;\n\n// Refresh interval: 4 hours (14400000ms)\nconst REFRESH_INTERVAL_MS = 4 * 60 * 60 * 1000;\n\n/**\n * Initialize proxy auto-refresh\n * Called once when app starts\n */\nexport async function initializeProxyManager(): Promise<void> {\n  // Only initialize if 2captcha API key is configured\n  if (!process.env.TWOCAPTCHA_API_KEY) {\n    console.log('[ProxyInit] Skipping proxy initialization (no API key)');\n    return;\n  }\n  if (process.env.PROXY_SERVER && process.env.PROXY_SERVER !== 'disabled') {\n    console.log('[ProxyInit] Static proxy configured, loading...');\n    await proxyManager.fetchProxies();\n    await proxyManager.activate('Static proxy configured');\n    const status = proxyManager.getStatus();\n    console.log(`[ProxyInit] Static proxy ready - ${status.available}/${status.total} proxies`);\n    return;\n  }\n\n  console.log('[ProxyInit] Initializing proxy auto-refresh...');\n\n  // Initial refresh\n  try {\n    await refreshProxies();\n  } catch (error) {\n    console.error('[ProxyInit] Initial refresh failed:', error);\n  }\n\n  // Set up periodic refresh (every 4 hours)\n  if (refreshInterval) {\n    clearInterval(refreshInterval);\n  }\n\n  refreshInterval = setInterval(async () => {\n    try {\n      await refreshProxies();\n    } catch (error) {\n      console.error('[ProxyInit] Periodic refresh failed:', error);\n    }\n  }, REFRESH_INTERVAL_MS);\n\n  console.log(`[ProxyInit] Auto-refresh scheduled every ${REFRESH_INTERVAL_MS / 1000 / 60 / 60} hours`);\n}\n\n/**\n * Refresh proxies if needed\n */\nasync function refreshProxies(): Promise<void> {\n  const now = Date.now();\n\n  // Skip if refreshed recently (within 5 minutes)\n  if (now - lastRefresh < 5 * 60 * 1000) {\n    console.log('[ProxyInit] Skipping refresh (too recent)');\n    return;\n  }\n\n  console.log('[ProxyInit] Refreshing proxies...');\n  await proxyManager.refresh();\n  lastRefresh = now;\n\n  const status = proxyManager.getStatus();\n  console.log(`[ProxyInit] Refresh complete - ${status.available}/${status.total} proxies available`);\n}\n\n/**\n * Force refresh proxies (called on-demand)\n * This calls proxyManager.fetchProxies() to actually update the proxy pool\n */\nexport async function forceRefreshProxies(): Promise<void> {\n  console.log('[ProxyInit] Force refreshing proxies via proxyManager...');\n  lastRefresh = 0; // Reset to allow immediate refresh\n\n  const apiKey = process.env.TWOCAPTCHA_API_KEY;\n  if (!apiKey) {\n    console.log('[ProxyInit] No API key configured - cannot fetch proxies');\n    return;\n  }\n\n  try {\n    // Use proxyManager.fetchProxies() to actually populate the proxy pool\n    const proxies = await proxyManager.fetchProxies();\n    console.log(`[ProxyInit] ProxyManager now has ${proxies.length} proxies`);\n\n    // Also ensure proxy mode is active\n    if (proxies.length > 0 && !proxyManager.getStatus().isActive) {\n      await proxyManager.activate('Force refresh - proxies available');\n    }\n  } catch (error) {\n    console.error('[ProxyInit] Failed to refresh proxies:', error);\n  }\n}\n\n/**\n * Stop auto-refresh (cleanup)\n */\nexport function stopProxyRefresh(): void {\n  if (refreshInterval) {\n    clearInterval(refreshInterval);\n    refreshInterval = null;\n    console.log('[ProxyInit] Auto-refresh stopped');\n  }\n}\n\n// Auto-initialize on import (happens once per Node.js process)\nif (typeof window === 'undefined') {\n  // Only run in server environment\n  initializeProxyManager().catch(err => {\n    console.error('[ProxyInit] Failed to initialize:', err);\n  });\n}\n"],"names":[],"mappings":"wCAOA,IAAA,EAAA,EAAA,CAAA,CAAA,QAGA,IAAI,EAAc,EACd,EAAyC,KAStC,eAAe,IAEpB,GAAI,CAAC,QAAQ,GAAG,CAAC,kBAAkB,CAAE,YACnC,QAAQ,GAAG,CAAC,0DAGd,GAAI,QAAQ,GAAG,CAAC,YAAY,EAAiC,aAA7B,QAAQ,GAAG,CAAC,YAAY,CAAiB,CACvE,QAAQ,GAAG,CAAC,mDACZ,MAAM,EAAA,YAAY,CAAC,YAAY,GAC/B,MAAM,EAAA,YAAY,CAAC,QAAQ,CAAC,2BAC5B,IAAM,EAAS,EAAA,YAAY,CAAC,SAAS,GACrC,QAAQ,GAAG,CAAC,CAAC,iCAAiC,EAAE,EAAO,SAAS,CAAC,CAAC,EAAE,EAAO,KAAK,CAAC,QAAQ,CAAC,EAC1F,MACF,CAEA,QAAQ,GAAG,CAAC,kDAGZ,GAAI,CACF,MAAM,GACR,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,sCAAuC,EACvD,CAGI,GACF,cADmB,AACL,GAGhB,EAAkB,YAAY,UAC5B,GAAI,CACF,MAAM,GACR,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,uCAAwC,EACxD,CACF,EAzC0B,CAyCvB,GAzC2B,GA2C9B,EA3CmC,KAAK,CA2ChC,GAAG,CAAC,CAAC,yCAAyC,EAAE,OAC1D,CAKA,cANgF,CAMjE,IACb,EAPqF,EAO/E,EAAM,CAP8E,GAAG,CAO5E,GAAG,EAP+E,CAAC,AAUpG,GAAI,EAAM,EAAc,IAAI,AAAW,KAAN,OAC/B,QAAQ,GAAG,CAAC,6CAId,QAAQ,GAAG,CAAC,qCACZ,MAAM,EAAA,YAAY,CAAC,OAAO,GAC1B,EAAc,EAEd,IAAM,EAAS,EAAA,YAAY,CAAC,SAAS,GACrC,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,EAAO,SAAS,CAAC,CAAC,EAAE,EAAO,KAAK,CAAC,kBAAkB,CAAC,CACpG,CAMO,eAAe,IAKpB,GAJA,QAAQ,GAAG,CAAC,4DACZ,EAAc,EAGV,CADW,AAFE,AAGZ,QADkB,GAAG,CAAC,kBAAkB,CAChC,IAHuC,QAIlD,QAAQ,GAAG,CAAC,4DAId,GAAI,CAEF,IAAM,EAAU,MAAM,EAAA,YAAY,CAAC,YAAY,GAC/C,QAAQ,GAAG,CAAC,CAAC,iCAAiC,EAAE,EAAQ,MAAM,CAAC,QAAQ,CAAC,EAGpE,EAAQ,MAAM,CAAG,GAAK,CAAC,EAAA,YAAY,CAAC,SAAS,GAAG,QAAQ,EAAE,AAC5D,MAAM,EAAA,YAAY,CAAC,QAAQ,CAAC,oCAEhC,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,yCAA0C,EAC1D,CACF,CAKO,SAAS,IACV,IACF,aADmB,CACL,GACd,EAAkB,KAClB,QAAQ,GAAG,CAAC,oCAEhB,CAKE,IAAyB,KAAK,CAAC,IAC7B,QAAQ,KAAK,CAAC,oCAAqC,EACrD"}}]
}